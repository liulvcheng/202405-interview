
### props 如何同步更新父子组件
1. v-bind 加上 sync 修饰符（具体还是需要在子组件中 emit 事件，只是说父组件中不需要监听事件来手动改变 v-bind 绑定的值
```JavaScript
// 父组件
<template>
  <div>
    <ChildComponent :value.sync="parentValue" />
  </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: { ChildComponent },
  data() {
    return {
      parentValue: 'initial value'
    };
  }
};
</script>

// 子组件
<template>
  <div>
    <input :value="value" @input="handleInput" />
  </div>
</template>

<script>
export default {
  props: ['value'],
  methods: {
    handleInput(event) {
      // 触发后父组件不需要手动接收来改变
      this.$emit('update:value', event.target.value);
    }
  }
};
</script>

// sync 是 :prop 和 @update:prop 的结合
<ChildComponent :value.sync="parentValue" />
// 等同于
<ChildComponent :value="parentValue" @update:value="parentValue = $event" />
```

2. v-model 的本质（绑定 value 和监听 input 事件的结合
```JavaScript
// 父组件
<template>
  <div>
    <ChildComponent v-model="parentValue" />
  </div>
</template>

<script>
import ChildComponent from './ChildComponent.vue';

export default {
  components: { ChildComponent },
  data() {
    return {
      parentValue: 'initial value'
    };
  }
};
</script>

// 子组件
<template>
  <div>
    <input :value="value" @input="handleInput" />
  </div>
</template>

<script>
export default {
  props: ['value'],
  methods: {
    handleInput(event) {
      this.$emit('input', event.target.value);
    }
  }
};
</script>
```

### provide、inject 是动态的还是静态的（如何做到动态更新
1. 静态传递就是使用正常的变量；动态传递就是使用被 ref、reactive 包裹的变量
```JavaScript
// provide 普通值
<script setup>
import { provide } from 'vue'
provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
</script>

// provide 响应式值
import { ref, provide } from 'vue'
const count = ref(0)
provide('key', count)
```

2. provide、inject 的使用建议保持单向数据流的原则
- provide 数据的改变建议在 provide 方执行（当然触发可以在 inject 一方）
- 实际运用中可以在 inject 方改变 provide 的数据，这是 provide 方的数据会同步更新，但这种方式在大型应用中可能会造成数据混乱或数据状态不好更新
```JavaScript
// 在供给方组件内
<script setup>
import { provide, ref } from 'vue'
const location = ref('North Pole')

// 改变数据的事件
function updateLocation() {
  location.value = 'South Pole'
}

provide('location', {
  location,
  updateLocation
})
</script>

// 在注入方组件
<script setup>
import { inject } from 'vue'
const { location, updateLocation } = inject('location')
</script>

<template>
  // 在 inject 方触发，但实际更改是在 provide 方
  <button @click="updateLocation">{{ location }}</button>
</template>
```

3. provide 的数据不能被修改（使用 readonly 包装
```JavaScript
<script setup>
import { ref, provide, readonly } from 'vue'

const count = ref(0)
provide('read-only-count', readonly(count))
</script>
```

4. 使用 Symbol 作为注入名（可以避免同名情况；减少潜在的冲突
```JavaScript
// keys.js
// 全局导出一个 Symbol 值（每次被调用时都是不一样的 Symbol
export const myInjectionKey = Symbol()

// 在供给方组件中
import { provide } from 'vue'
import { myInjectionKey } from './keys.js'
provide(myInjectionKey, { /*
  要提供的数据
*/ });

// 注入方组件
import { inject } from 'vue'
import { myInjectionKey } from './keys.js'
const injected = inject(myInjectionKey)
```

### 具名插槽、作用域插槽

### 对于函数而言 arguments 和 rest 参数的主要区别是什么

### vue3 v-model 有什么变化

### css 中如何解决 margin 合并和 margin 塌陷

### eventBus 的 emit、on 事件

### vue3 created 生命周期和 setup 谁先执行

### router push query 和 params 时如何在指定页面拿到对应的路由参数
