### html5 新的语义化标签

### css 中选择器优先级

### break、continue、return 退出循环有什么区别

### 浏览器的重排和重绘

### 同源策略是什么

### 常见的 http 状态码有哪些（403、5xx、3xx、2xx）

### css 的引入方式有哪些

### vu2、vue3 的区别
1. 按需引入

2. hooks

### async await 是用来编写同步代码的嘛
1. async await 使得一些异步操作代码（延时执行的回调函数、延时执行的 Promise）可以同步执行

2. async await 不会阻塞事件循环（还是不太理解）
```JavaScript
// GPT：'在 func 函数内部，执行到 await 时，函数暂停，但事件循环继续运行，不会被阻塞。事件循环仍然可以处理其他异步任务或事件，即使此时没有其他任务，事件循环仍然处于等待状态，准备处理未来到达的任务。这样，应用程序可以保持响应性'
// 当代码中不只有 func 函数的时候 func 函数 await 时事件循环可以走其他的代码逻辑
async function func() {
  console.log('1')
  await new Promise((resolve) =>
    setTimeout(() => {
      console.log('3')
      resolve()
    }, 1000)
  )
  console.log('2')
}

func() // 1 3 2
```

### vue2 中 data 的定义为什么需要是函数 return 而不是一个对象这样

### 数组去重有哪些方法
1. set
```JavaScript
const array = [1, 2, 2, 3, 4, 4, 5];
const uniqueArray = [...new Set(array)];

console.log(uniqueArray); // [1, 2, 3, 4, 5]
```

2. filter + indexOf
```JavaScript
const array = [1, 2, 2, 3, 4, 4, 5];
const uniqueArray = array.filter((item, index) => array.indexOf(item) === index);

console.log(uniqueArray); // [1, 2, 3, 4, 5]
```

3. reduce
```JavaScript
const array = [1, 2, 2, 3, 4, 4, 5];
const uniqueArray = array.reduce((acc, item) => {
  if (!acc.includes(item)) {
    acc.push(item);
  }
  return acc;
}, []);

console.log(uniqueArray); // [1, 2, 3, 4, 5]
```

4. 利用对象键或者 Map 键的唯一性
```JavaScript
// Object
const array = [1, 2, 2, 3, 4, 4, 5];
const uniqueObj = {};
const uniqueArray = array.filter(item => {
  if (!uniqueObj[item]) {
    uniqueObj[item] = true;
    return true;
  }
  return false;
});

console.log(uniqueArray); // [1, 2, 3, 4, 5]

// Map
const array = [1, 2, 2, 3, 4, 4, 5];
const map = new Map();
const uniqueArray = [];

array.forEach(item => {
  if (!map.has(item)) {
    map.set(item, true);
    uniqueArray.push(item);
  }
});

console.log(uniqueArray); // [1, 2, 3, 4, 5]
```

5. lodash 库
```JavaScript
const _ = require('lodash'); // 或者使用 <script src="https://cdn.jsdelivr.net/npm/lodash/lodash.min.js"></script>
const array = [1, 2, 2, 3, 4, 4, 5];
const uniqueArray = _.uniq(array);

console.log(uniqueArray); // [1, 2, 3, 4, 5]
```

### 箭头函数有自己的 argments 嘛
1. 箭头函数没有自己的 argments
```JavaScript
const arrowFunc = () => {
  console.log(arguments)
}
function func() {
  console.log(arguments)
}
// GPT：'因为箭头函数不会创建自己的 arguments 对象。它会引用其外部作用域中的 arguments 对象，但在这个例子中，外部作用域是全局作用域，arguments 并不存在或未定义。因此，可能会抛出错误或者输出一个空的 arguments 对象或 undefined'
arrowFunc(1, 2, 3) // 输出一推奇怪的东西
func(1, 2, 3) // [Arguments] { '0': 1, '1': 2, '2': 3 }
```

2. 箭头函数的 this 是其定义时父级作用域的 this（最顶层就是 window、global）

3. 箭头函数不能用作构造函数
- 没有 this 绑定、没有 prototype 属性
```JavaScript
// 箭头函数不能作为构造函数
const ArrowFunc = () => {
  this.value = 42;
};
// 尝试用箭头函数作为构造函数
try {
  const obj = new ArrowFunc();
} catch (e) {
  console.log(e); // TypeError: ArrowFunc is not a constructor
}

// es5
function NormalFunc() {
  this.value = 42;
}
const obj = new NormalFunc();
console.log(obj.value); // 42

// es6
class MyClass {
  constructor() {
    this.value = 42;
  }
}
const obj = new MyClass();
console.log(obj.value); // 42
```

### 伪类、伪元素
